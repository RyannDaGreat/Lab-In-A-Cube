Notes:
	*In general, my function names work like this: If it's a verb, it probably mutates something (which is more efficient generally). Examples: copy, apply. Else, it probably is a pure function that returns something Example: copied, blended etc. If it's 
	*Javascript is REALLY annoying. It doesn't even check to make sure I gave functions the right number of arguments. I have been trying to mitigate mysterious 'undefined' errors that I spent hours debugging just to find out I forgot to put an assertion like "console.assert(arguments.length===2,'Wrong number of arguments.')" into one of my functions. Keep this in mind. (IDE's can help with this somewhat with autocompletion though)
	*In the djson, 'deltas' in transitions are space-separated strings of (possibly multiple) deltas composed together. this will also be how the state's delta stack will be represented. This is beautiful because of the djson rule that prohibits any whitespace in key names, but allows it in value names. (AKA no deltaID's can possibly have spaces or tabs in them. We also assume that no deltaID's have empty strings, but I haven't acually added a check for that as of March25/2019)
	*Inheritance of deltas is a thing. One delta can inherit from multiple others, but these others have to have some defined order to them (because order matters). Circular inheritance SHOULD be possible, because of the finite nature of deltas. But right now, as of March25/2019, this will cause an infinite loop (which should later be fixed).
	*A composition of deltas is one applied after the other to create new deltas (they're associative)
	*Delta inheritance chains: Important conjecture: Any compotision of deltas of length N, chosen from a set of P possible deltas, can be represented as a composition of deltas with length less than P. (For example, take composition ABA which is equal to BA. Only the last one of each matters). This is important in understanding the function getDeltaInheritanceChain
	*The LAST delta in an inheritance chain always gets applied last, so it's never overwritten etc...this might seem slightly counterintuitive at first, but it's actually not.
	*'Comments' can be made in djson, just line any other language (except that these 'comments' actually affect the data. It's just that in practice, my program won't actually read them. You can use '//' as a key, then any non-tabbed single line comment after it.)
	*I added mouse-over transitions. I would reccomend never setting the time too high on them though, because async transitions aren't a thing right now.
	*In JSON's, .3 is an invalid number. In DJSON, it is. (Also, -.5 is invalid JSON but valid DJSON)

	Later I'd like to make the background of the scene clickable, but right now this would require a lot of refactoring...this is a problem for another day. (April 1)

	Currently auto-transition doesn't work with simple conditions. This must be fixed. (April 1)

	Right now the engine doesn't work on my iphone or ipad. I should fix this. 
	Right now the sand font isn't loading properly onto other peoples' computers. THis should be fixed
	Font-size should appear more uniform across computers ; measuring in px might not be such a good idea

RESERVED:
	Deltas:
		initial
		on_exit


DELTAS CONTAIN:
	INHERITANCE
	SIMPLE CONDITIONS: two arguments: a deltaID, and an (optional) deltaID. If the first one is contained within current state, then: if there's a second argument, return that deltaID instead. Else, just return an empty delta {} (without doing any inheritance). NOTE: we must keep track of branches that failed, because if we bounce back and fourth between a few deltas that have failed we would like to return {} instead. This handles the case of a possible loop between deltas A and B, where A is told to go to B and B is told to go to A because of some impossible-to-meet condition. 
	These are metadata for when the condition is evaluated.
	BUT WAIT: WOULD CONDITIONS MESS UP PROPERTIES OF DELTAS, AND IF SO WOULD IT MATTER??


BUGS:
	WHY is 
		~scope
			 We're going to pour the beaker into the flask
			items	beaker~n mesh
			items	flask~n mesh
			deltas	initial	beaker~n	transform	position	x bx	y by	z bz
			deltas	initial	flask~n		transform	position	x fx	y fy	z fz
			deltas	pour~n	flask~n		transform	position	x bx	y by~+1	z bz
			deltas	pour~n	scene	transitions	auto						delta initial	time 1
			deltas	initial	scene	transitions	drag	beaker~n	flask~n	delta pour~n	time 1
			~	i	n i	bx i~00	by -50	bz 0	fx i~00	fy 0	fz 100
			~	~	0	i 0
			~	~	1	i 1
			~	~	2	i 2
			~	~	3	i 3
	DIFFERENT FROM
		~scope
		 We're going to pour the beaker into the flask
		items	beaker~n mesh
		items	flask~n mesh
		deltas	initial	beaker~n	transform	position	x bx	y by	z bz
		deltas	initial	flask~n		transform	position	x fx	y fy	z fz
		deltas	pour~n	flask~n		transform	position	x bx	y by~+1	z bz
		deltas	pour~n	scene	transitions	auto						delta initial	time 1
		deltas	initial	scene	transitions	drag	beaker~n	flask~n	delta pour~n	time 1
		~
			i	n i	bx i~00	by -50	bz 0	fx i~00	fy 0	fz 100
			~
				0	i 0
				1	i 1
				2	i 2
				3	i 3
	ONLY WHEN USING MACROS??!


An 'other' option for clicking/dragging (dragging into someting 'else', not specified in scene transitions)

TODO
	No more communicating through local storage; directly access memory instead
	Make strip-trailing-spaces post-processing option

	â€¢ IDEALLY i'd like to modularize textures/materials/etc, and make them something you have to create in the same way as 'object' etc. This would eliminate the need for 'mode modes' and would let multiple objects share the same material, texture, etc. 
	TO DO THIS: deltas would need to be capable of modifying MORE than just items. They would have to be capable of modifying textures? Or perhaps textures and materials etc could BE item types??
		++ IDEA: Put items, geometries, etc all in one big object called 'config', and let deltas change everything (including other deltas) in that config  ******THIS IDEA IS DANGEROUS BECAUSE IT COULD BREAK THE ASSOCIATIVE PROPERTY OF DELTAS (if they can modify other deltas)

	2D GUI
	Flask Liquid
	Conditions

	Texture Loading
	Add sounds
	Add optional smoothing 
	Add sky/better lighting
	Add beakers with variable fluid levels
	Add GUI
	Make editor NOT dissapear when we zoom in too much (why does it do that??)
	Toggle Visibility -- objects that aren't visible should let raytracing pass through
	Make a stack of deltas so we can edit in realtime for real
	Finish the macro system correctly
	Keys-with-spaces in dJson + syntax highlighting
	dJson: Add post-processing as part of the dJSON reading settings (local to scope)
	Persistent Undo in editor
	Let camera move around
	Add .. to djson	(and deltas to djson's without reformatting) (and better djson formatting)



*** WHY THE HELL DOES THIS BREAK ON SAFARI AND FIREFOX BUT WORK ON CHROME?!?!? Answer: There was no localstorage config there?? (no, I think its beyond that...)

